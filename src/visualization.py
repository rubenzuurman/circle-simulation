"""
Visualization class.
"""
import os
import pickle
import time

import pygame

from camera import Camera

class Visualization:
    """
    Visualizes data generated by the Simulation class.
    """
    
    def __init__(self, simulation_name, window_dimensions):
        """
        Initializes window.
        """
        # Initialize pygame.
        pygame.init()
        pygame.font.init()
        
        # Initialize font.
        self.font = pygame.font.SysFont("Courier New", 16)
        
        # Set member variables.
        self.simulation_name = simulation_name
        self.window_width = window_dimensions[0]
        self.window_height = window_dimensions[1]
        self.window_dimensions = window_dimensions
        
        # Check if the simulation exists.
        if not os.path.isdir(f"saves/{simulation_name}/"):
            raise Exception(f"Simulation does not exist `{simulation_name}`.")
        
        # Load simulation properties.
        self.simprops = {}
        self.load_simulation_properties()
        
        # Load simulation data. Simdata contains the data from a simulation 
        # file at any point in time. It gets overwritten if the next file is 
        # required to be loaded.
        self.simdata = {}
        self.current_chunk = 0
        self.load_next_chunk()
        self.timestep = 0
        
        # Create camera object.
        self.camera = Camera()
        
        # Create display.
        self.display = pygame.display.set_mode(window_dimensions)
        pygame.display.set_caption("Visualizer of simulation " \
            f"`{simulation_name}`")
        
        # Create clock.
        self.clock = pygame.time.Clock()
    
    def load_simulation_properties(self):
        """
        Investigates the simulation folder to gather important properties.
        These properties include:
            - Index numbers of available files.
            - Maximum index number.
        """
        # Initialize properties dictionary.
        self.simprops = {}
        
        # Search folder.
        available_indices = []
        for file in os.listdir(f"saves/{self.simulation_name}/"):
            if file.startswith("timestep"):
                index = int(file.split(".")[0][8:])
                available_indices.append(index)
        
        # Sort indices.
        available_indices = sorted(available_indices)
        
        # Remove negative indices.
        available_indices = [index for index in available_indices \
                                if index >= 0]
        
        # Check if any index is missing between zero and the maximum.
        for list_index, index in enumerate(available_indices):
            if not list_index == index:
                raise Exception(f"Missing simulation file " \
                    f"`saves/{self.simulation_name}/" \
                    f"timestep{list_index}.pickle`.")
        
        # Store index list in dictionary.
        self.simprops["indices"] = available_indices
        
        # Store maximum index in dictionary.
        self.simprops["max_index"] = max(available_indices)
        
        # Store delta time in dictionary.
        with open(f"saves/{self.simulation_name}/timestep0.pickle", "rb") \
            as file:
            simdata = pickle.load(file)
        self.simprops["delta_time"] = simdata[1]["current_time"] - simdata[0]["current_time"]
    
    def load_next_chunk(self):
        """
        Loads the next chunk.
        """
        # Check if the dictionary is empty, if it is load the first chunk.
        if len(self.simdata) == 0:
            filename_chunk = f"saves/{self.simulation_name}/timestep0.pickle"
            with open(filename_chunk, "rb") as file:
                chunk = pickle.load(file)
            self.simdata = chunk
            return True
        
        # If it's not empty load the next chunk.
        self.current_chunk += 1
        filename_chunk = f"saves/{self.simulation_name}/" \
            f"timestep{self.current_chunk}.pickle"
        if not os.path.exists(filename_chunk):
            return False
        with open(filename_chunk, "rb") as file:
            chunk = pickle.load(file)
        self.simdata = chunk
        return True
    
    def run(self, fps):
        """
        Main render loop.
        """
        # Render settings.
        render_particle_ids = False
        speedup = 32
        
        # Timing variables.
        last_time = 0
        current_time = time.time_ns()
        delta_time = 0
        
        timer_start = 0
        
        timestep_data = None
        
        temp_fps_time = time.time_ns()
        temp_fps = 0
        
        temp_last10_frame_times = []
        loading_time_total = 0
        
        # Start render loop.
        keys_pressed = [False, False, False, False, False, False]
        running = True
        while running:
            frame_times = {}
            frame_times["base"] = time.time_ns()
            
            for event in pygame.event.get():
                # Detect quit event.
                if event.type == pygame.QUIT:
                    running = False
                
                # Detect escape keypress.
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        running = False
                    
                    if event.key == pygame.K_w:
                        keys_pressed[0] = True
                    if event.key == pygame.K_a:
                        keys_pressed[1] = True
                    if event.key == pygame.K_s:
                        keys_pressed[2] = True
                    if event.key == pygame.K_d:
                        keys_pressed[3] = True
                    if event.key == pygame.K_UP:
                        keys_pressed[4] = True
                    if event.key == pygame.K_DOWN:
                        keys_pressed[5] = True
                
                if event.type == pygame.KEYUP:
                    if event.key == pygame.K_w:
                        keys_pressed[0] = False
                    if event.key == pygame.K_a:
                        keys_pressed[1] = False
                    if event.key == pygame.K_s:
                        keys_pressed[2] = False
                    if event.key == pygame.K_d:
                        keys_pressed[3] = False
                    if event.key == pygame.K_UP:
                        keys_pressed[4] = False
                    if event.key == pygame.K_DOWN:
                        keys_pressed[5] = False
            
            # Calculate delta time.
            if last_time == 0:
                current_time = time.time_ns()
                last_time = current_time
                continue
            
            current_time = time.time_ns()
            delta_time = current_time - last_time
            last_time = current_time
            
            if current_time - temp_fps_time > 1000000000:
                temp_fps_time = current_time
                print(temp_fps)
                temp_fps = 0
            
            # If the timer is zero set the start.
            if timer_start == 0:
                timer_start = time.time_ns()
            
            frame_times["after_input_handling"] = time.time_ns()
            
            # Update camera.
            self.camera.update(delta_time / 1000000000, keys_pressed)
            
            frame_times["after_camera_update"] = time.time_ns()
            
            # Calculate current timestep.
            zzz_time_diff = (current_time - timer_start - loading_time_total) / 1000000000
            zzz_time_per_step = self.simprops["delta_time"] / speedup
            current_timestep = int(zzz_time_diff / zzz_time_per_step)
            
            # Update timestep data and load new chunk if required.
            self.timestep = current_timestep
            if not self.timestep in self.simdata.keys():
                loading_start = time.time_ns()
                running = self.load_next_chunk()
                if not running:
                    continue
                loading_end = time.time_ns()
                loading_time_total += loading_end - loading_start
            timestep_data = self.simdata[self.timestep]
            
            frame_times["after_simdata_update"] = time.time_ns()
            
            # Fill screen with black.
            self.display.fill((0, 0, 0))
            
            # Render particles.
            for particle in timestep_data["particles"]:
                particle_id, position, _, _, radius = particle
                
                pos_x = self.camera.get_zoom() \
                    * (position[0] - self.camera.get_position()[0]) \
                    + self.window_width // 2
                pos_y = self.camera.get_zoom() \
                    * (position[1] - -self.camera.get_position()[1]) \
                    + self.window_height // 2
                
                if pos_x < 0 or pos_y < 0 \
                    or pos_x > self.window_width \
                    or pos_y > self.window_height:
                    continue
                
                pygame.draw.circle(self.display, (255, 255, 255), \
                    (pos_x, pos_y), max(int(radius * self.camera.zoom), 1))
                
                # Render particle ids if enabled.
                if render_particle_ids:
                    self.render_text(f"{particle_id}", (pos_x - 5, pos_y - 20))
            
            # Render text.
            self.render_text(f"Timestep: {self.timestep}", (10, 10))
            current_time = round(timestep_data["current_time"], 1)
            max_time = round(timestep_data["max_time"], 1)
            self.render_text(f"Simulation time: " \
                f"{current_time}/{max_time}", (10, 30))
            num_of_particles = timestep_data['number_of_particles']
            self.render_text(f"Particles: {num_of_particles}", (10, 50))
            
            self.render_text(f"Camera position: " \
                f"{self.camera.get_position()}", (10, 90))
            self.render_text(f"Camera zoom: " \
                f"{self.camera.get_zoom()}", (10, 110))
            
            input_handling_time = sum([e["after_input_handling"] - e["base"] \
                for e in temp_last10_frame_times]) / max(len(temp_last10_frame_times), 1) / 1000
            camera_update_time = sum([e["after_camera_update"] - e["after_input_handling"] \
                for e in temp_last10_frame_times]) / max(len(temp_last10_frame_times), 1) / 1000
            simdata_update_time = sum([e["after_simdata_update"] - e["after_camera_update"] \
                for e in temp_last10_frame_times]) / max(len(temp_last10_frame_times), 1) / 1000
            render_time = sum([e["after_render"] - e["after_simdata_update"] \
                for e in temp_last10_frame_times]) / max(len(temp_last10_frame_times), 1) / 1000
            
            self.render_text("Last 10 frames average times", (10, 150))
            self.render_text(f"Input handling: {input_handling_time:.2f} μs", (10, 170))
            self.render_text(f"Camera update: {camera_update_time:.2f} μs", (10, 190))
            self.render_text(f"Simdata update: {simdata_update_time:.2f} μs", (10, 210))
            self.render_text(f"Render time: {render_time:.2f} μs", (10, 230))
            
            # Update display.
            pygame.display.flip()
            
            frame_times["after_render"] = time.time_ns()
            temp_last10_frame_times.append(frame_times)
            if len(temp_last10_frame_times) > 10:
                temp_last10_frame_times = temp_last10_frame_times[1:]
            
            temp_fps += 1
            
            # Tick clock.
            self.clock.tick(fps)
        
        # Quit pygame when the render loop is done.
        pygame.quit()
    
    def render_text(self, text, position):
        """
        Assumes text is a string and position is an iterable containing two 
        integers. Renders the text with the topleft at the specified position.
        """
        text_surface = self.font.render(text, False, (255, 0, 0))
        self.display.blit(text_surface, position)
