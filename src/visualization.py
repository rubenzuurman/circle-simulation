"""
Visualization class.
"""
import os

import pickle
import pygame

class Visualization:
    """
    Visualizes data generated by the Simulation class.
    """
    
    def __init__(self, simulation_name, window_dimensions):
        """
        Initializes window.
        """
        # Initialize pygame.
        pygame.init()
        
        # Set member variables.
        self.simulation_name = simulation_name
        self.window_width = window_dimensions[0]
        self.window_height = window_dimensions[1]
        self.window_dimensions = window_dimensions
        
        # Check if the simulation exists.
        if not os.path.isdir(f"saves/{simulation_name}/"):
            raise Exception(f"Simulation does not exist `{simulation_name}`.")
        
        # Load simulation properties.
        self.simprops = {}
        self.load_simulation_properties()
        
        # Load simulation data. Simdata contains the data from a simulation 
        # file at any point in time. It gets overwritten if the next file is 
        # required to be loaded.
        self.simdata = {}
        self.current_chunk = 0
        self.load_next_chunk()
        self.timestep = 0
        
        # Create display.
        self.display = pygame.display.set_mode(window_dimensions)
        pygame.display.set_caption("Visualizer of simulation " \
            f"`{simulation_name}`")
        
        # Create clock.
        self.clock = pygame.time.Clock()
    
    def load_simulation_properties(self):
        """
        Investigates the simulation folder to gather important properties.
        These properties include:
            - Index numbers of available files.
            - Maximum index number.
        """
        # Initialize properties dictionary.
        self.simprops = {}
        
        # Search folder.
        available_indices = []
        for file in os.listdir(f"saves/{self.simulation_name}/"):
            if file.startswith("timestep"):
                index = int(file.split(".")[0][8:])
                available_indices.append(index)
        
        # Sort indices.
        available_indices = sorted(available_indices)
        
        # Remove negative indices.
        available_indices = [index for index in available_indices \
                                if index >= 0]
        
        # Check if any index is missing between zero and the maximum.
        for list_index, index in enumerate(available_indices):
            if not list_index == index:
                raise Exception(f"Missing simulation file " \
                    f"`saves/{self.simulation_name}/" \
                    f"timestep{list_index}.pickle`.")
        
        # Store index list in dictionary.
        self.simprops["indices"] = available_indices
        
        # Store maximum index in dictionary.
        self.simprops["max_index"] = max(available_indices) 
    
    def load_next_chunk(self):
        """
        Loads the next chunk.
        """
        # Check if the dictionary is empty, if it is load the first chunk.
        if len(self.simdata) == 0:
            filename_chunk = f"saves/{self.simulation_name}/timestep0.pickle"
            with open(filename_chunk, "rb") as file:
                chunk = pickle.load(file)
            self.simdata = chunk
            return True
        
        # If it's not empty load the next chunk.
        self.current_chunk += 1
        filename_chunk = f"saves/{self.simulation_name}/" \
            f"timestep{self.current_chunk}.pickle"
        if not os.path.exists(filename_chunk):
            return False
        with open(filename_chunk, "rb") as file:
            chunk = pickle.load(file)
        self.simdata = chunk
        return True
    
    def run(self, fps):
        """
        Main render loop.
        """
        # Start render loop.
        running = True
        while running:
            for event in pygame.event.get():
                # Detect quit event.
                if event.type == pygame.QUIT:
                    running = False
                
                # Detect escape keypress.
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        running = False
            
            # Fill screen with black.
            self.display.fill((0, 0, 0))
            
            # Load new simulation data if required.
            if self.timestep not in list(self.simdata.keys()):
                running = self.load_next_chunk()
                if not running:
                    continue
            
            # Get current timestep data and increment timestep.
            timestep_data = self.simdata[self.timestep]
            self.timestep += 1
            
            # Render particles.
            for particle in timestep_data["particles"]:
                position = particle[1]
                
                pos_x = position[0] + self.window_width // 2
                pos_y = position[1] + self.window_height // 2
                
                pygame.draw.circle(self.display, (255, 255, 255), \
                    (pos_x, pos_y), 5)
            
            # Update display.
            pygame.display.flip()
            
            # Tick clock.
            self.clock.tick(fps)
        
        # Quit pygame when the render loop is done.
        pygame.quit()
