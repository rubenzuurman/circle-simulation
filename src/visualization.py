"""
Visualization class.
"""
import os
import pickle
import time

import pygame

from camera import Camera

class Visualization:
    """
    Visualizes data generated by the Simulation class.
    """
    
    def __init__(self, simulation_name, window_dimensions):
        """
        Initializes window.
        """
        # Initialize pygame.
        pygame.init()
        pygame.font.init()
        
        # Initialize font.
        self.font = pygame.font.SysFont("Courier New", 16)
        
        # Set member variables.
        self.simulation_name = simulation_name
        self.window_width = window_dimensions[0]
        self.window_height = window_dimensions[1]
        self.window_dimensions = window_dimensions
        
        # Check if the simulation exists.
        if not os.path.isdir(f"saves/{simulation_name}/"):
            raise Exception(f"Simulation does not exist `{simulation_name}`.")
        
        # Load simulation properties.
        self.simprops = {}
        self.load_simulation_properties()
        
        # Load simulation data. Simdata contains the data from a simulation 
        # file at any point in time. It gets overwritten if the next file is 
        # required to be loaded.
        self.simdata = {}
        self.current_chunk = 0
        self.load_next_chunk()
        self.timestep = 0
        
        # Create camera object.
        self.camera = Camera()
        
        # Create display.
        self.display = pygame.display.set_mode(window_dimensions)
        pygame.display.set_caption("Visualizer of simulation " \
            f"`{simulation_name}`")
        
        # Create clock.
        self.clock = pygame.time.Clock()
    
    def load_simulation_properties(self):
        """
        Investigates the simulation folder to gather important properties.
        These properties include:
            - Index numbers of available files.
            - Maximum index number.
        """
        # Initialize properties dictionary.
        self.simprops = {}
        
        # Search folder.
        available_indices = []
        for file in os.listdir(f"saves/{self.simulation_name}/"):
            if file.startswith("timestep"):
                index = int(file.split(".")[0][8:])
                available_indices.append(index)
        
        # Sort indices.
        available_indices = sorted(available_indices)
        
        # Remove negative indices.
        available_indices = [index for index in available_indices \
                                if index >= 0]
        
        # Check if any index is missing between zero and the maximum.
        for list_index, index in enumerate(available_indices):
            if not list_index == index:
                raise Exception(f"Missing simulation file " \
                    f"`saves/{self.simulation_name}/" \
                    f"timestep{list_index}.pickle`.")
        
        # Store index list in dictionary.
        self.simprops["indices"] = available_indices
        
        # Store maximum index in dictionary.
        self.simprops["max_index"] = max(available_indices) 
    
    def load_next_chunk(self):
        """
        Loads the next chunk.
        """
        # Check if the dictionary is empty, if it is load the first chunk.
        if len(self.simdata) == 0:
            filename_chunk = f"saves/{self.simulation_name}/timestep0.pickle"
            with open(filename_chunk, "rb") as file:
                chunk = pickle.load(file)
            self.simdata = chunk
            return True
        
        # If it's not empty load the next chunk.
        self.current_chunk += 1
        filename_chunk = f"saves/{self.simulation_name}/" \
            f"timestep{self.current_chunk}.pickle"
        if not os.path.exists(filename_chunk):
            return False
        with open(filename_chunk, "rb") as file:
            chunk = pickle.load(file)
        self.simdata = chunk
        return True
    
    def run(self, fps):
        """
        Main render loop.
        """
        # Timing variables.
        last_time = 0
        current_time = time.time_ns()
        delta_time = 0
        
        # Start render loop.
        keys_pressed = [False, False, False, False, False, False]
        running = True
        while running:
            for event in pygame.event.get():
                # Detect quit event.
                if event.type == pygame.QUIT:
                    running = False
                
                # Detect escape keypress.
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        running = False
                    
                    if event.key == pygame.K_w:
                        keys_pressed[0] = True
                    if event.key == pygame.K_a:
                        keys_pressed[1] = True
                    if event.key == pygame.K_s:
                        keys_pressed[2] = True
                    if event.key == pygame.K_d:
                        keys_pressed[3] = True
                    if event.key == pygame.K_UP:
                        keys_pressed[4] = True
                    if event.key == pygame.K_DOWN:
                        keys_pressed[5] = True
                
                if event.type == pygame.KEYUP:
                    if event.key == pygame.K_w:
                        keys_pressed[0] = False
                    if event.key == pygame.K_a:
                        keys_pressed[1] = False
                    if event.key == pygame.K_s:
                        keys_pressed[2] = False
                    if event.key == pygame.K_d:
                        keys_pressed[3] = False
                    if event.key == pygame.K_UP:
                        keys_pressed[4] = False
                    if event.key == pygame.K_DOWN:
                        keys_pressed[5] = False
            
            # Calculate delta time.
            if last_time == 0:
                current_time = time.time_ns()
                last_time = current_time
                continue
            else:
                current_time = time.time_ns()
                delta_time = current_time - last_time
                last_time = current_time
            
            # Update camera.
            self.camera.update(delta_time / 1000000000, keys_pressed)
            
            # Fill screen with black.
            self.display.fill((0, 0, 0))
            
            # Load new simulation data if required.
            if self.timestep not in list(self.simdata.keys()):
                running = self.load_next_chunk()
                if not running:
                    continue
            
            # Get current timestep data and increment timestep.
            timestep_data = self.simdata[self.timestep]
            self.timestep += 1
            
            # Render particles.
            for particle in timestep_data["particles"]:
                position = particle[1]
                
                pos_x = self.camera.get_zoom() \
                    * (position[0] - self.camera.get_position()[0]) \
                    + self.window_width // 2
                pos_y = self.camera.get_zoom() \
                    * (position[1] - -self.camera.get_position()[1]) \
                    + self.window_height // 2
                
                pygame.draw.circle(self.display, (255, 255, 255), \
                    (pos_x, pos_y), 5)
            
            # Render text.
            self.render_text(f"Timestep: {self.timestep}", (10, 10))
            current_time = round(timestep_data["current_time"], 1)
            max_time = round(timestep_data["max_time"], 1)
            self.render_text(f"Simulation time: " \
                f"{current_time}/{max_time}", (10, 30))
            num_of_particles = timestep_data['number_of_particles']
            self.render_text(f"Particles: {num_of_particles}", (10, 50))
            
            self.render_text(f"Camera position: " \
                f"{self.camera.get_position()}", (10, 90))
            self.render_text(f"Camera zoom: " \
                f"{self.camera.get_zoom()}", (10, 110))
            
            # Update display.
            pygame.display.flip()
            
            # Tick clock.
            self.clock.tick(fps)
        
        # Quit pygame when the render loop is done.
        pygame.quit()
    
    def render_text(self, text, position):
        text_surface = self.font.render(text, False, (255, 0, 0))
        self.display.blit(text_surface, position)
